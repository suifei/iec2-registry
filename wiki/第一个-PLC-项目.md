# 第一个 PLC 项目 — 从零开始

本教程将带你从一个空文件夹开始，完成一个完整的 PLC 项目：编写结构化文本（ST）程序、使用功能块、定义自定义数据类型，并成功编译。

## 目录

- [前置要求](#前置要求)
- [第一步：创建项目文件夹](#第一步创建项目文件夹)
- [第二步：编写第一个程序](#第二步编写第一个程序)
- [第三步：编译程序](#第三步编译程序)
- [第四步：ST 语言快速入门](#第四步st-语言快速入门)
- [第五步：构建完整项目](#第五步构建完整项目)
- [第六步：使用代码模板](#第六步使用代码模板)
- [第七步：在 IDE 中新建项目元素](#第七步在-ide-中新建项目元素)
- [理解 Demo 工程结构](#理解-demo-工程结构)
- [常见问题](#常见问题)

---

## 前置要求

- 已完成 [开箱即用 — 安装与快速上手](开箱即用-—-安装与快速上手.md)
- VS Code 中已安装 IEC 61131-3 PLC IDE 扩展

---

## 第一步：创建项目文件夹

1. 在你的工作目录中创建一个新文件夹，例如 `my-first-plc`
2. 在 VS Code 中打开该文件夹：**File → Open Folder**

此时侧边栏的 IEC Project 树应该是空的，这是正常的。

---

## 第二步：编写第一个程序

在项目根目录下创建文件 `Counter.st`，输入以下代码：

```iec
PROGRAM Counter
VAR
    count : INT := 0;
    limit : INT := 100;
    running : BOOL := TRUE;
    direction : BOOL := TRUE;  (* TRUE = 递增, FALSE = 递减 *)
END_VAR

IF running THEN
    IF direction THEN
        count := count + 1;
        IF count >= limit THEN
            direction := FALSE;
        END_IF;
    ELSE
        count := count - 1;
        IF count <= 0 THEN
            direction := TRUE;
        END_IF;
    END_IF;
END_IF;

END_PROGRAM
```

保存文件后，你应该看到：
- 关键字 `PROGRAM`、`VAR`、`INT`、`BOOL` 等有语法高亮
- 鼠标悬停在变量上会显示类型信息
- 如果有语法错误，编辑器会用红色波浪线标记

---

## 第三步：编译程序

### 方式 A：通过命令面板编译

1. 按 `Ctrl+Shift+P`（macOS: `Cmd+Shift+P`）
2. 输入 **"IEC: Build All"**
3. 编译结果输出在底部面板的 **终端** 或 **输出** 窗口中
4. 编译成功后，`dist/` 目录下会生成对应的 C 代码文件

### 方式 B：通过右键菜单编译

1. 在 IEC Project 树中右键点击项目根节点
2. 选择 **"IEC: Build All"**

### 方式 C：使用 Build Task

1. 按 `Ctrl+Shift+B`（macOS: `Cmd+Shift+B`）选择构建任务
2. 选择 **"iec: build"** 任务

### 编译输出

编译成功后会生成 ANSI C 代码，例如 `dist/linked.c`，内容类似：

```c
/* Generated by IECC2 - IEC 61131-3 Compiler */
#include "iec_runtime.h"

typedef struct {
    IEC_INT count;
    IEC_INT limit;
    IEC_BOOL running;
    IEC_BOOL direction;
} Counter_t;

void Counter__body(Counter_t *inst) {
    if (inst->running) {
        if (inst->direction) {
            inst->count = inst->count + 1;
            if (inst->count >= inst->limit) {
                inst->direction = 0;
            }
        } else {
            inst->count = inst->count - 1;
            if (inst->count <= 0) {
                inst->direction = 1;
            }
        }
    }
}
```

### 使用 GCC 编译为可执行文件（可选）

如果你安装了 GCC，可以将生成的 C 代码编译为本地可执行文件：

```bash
# 编译为包含 main() 的独立程序
iecc -emit-c -link -main -o dist/linked.c Counter.st

# 用 GCC 编译
gcc -o counter dist/linked.c
./counter
```

---

## 第四步：ST 语言快速入门

### 4.1 数据类型

IEC 61131-3 提供丰富的基本数据类型：

| 类型 | 说明 | 示例 |
|------|------|------|
| `BOOL` | 布尔值 | `TRUE`, `FALSE` |
| `INT` | 16 位有符号整数 | `-32768` ~ `32767` |
| `DINT` | 32 位有符号整数 | |
| `LINT` | 64 位有符号整数 | |
| `UINT` | 16 位无符号整数 | |
| `REAL` | 32 位浮点数 | `3.14` |
| `LREAL` | 64 位浮点数 | |
| `STRING` | 字符串 | `'Hello'` |
| `TIME` | 时间 | `T#1s`, `T#500ms` |
| `BYTE` | 8 位无符号 | |
| `WORD` | 16 位无符号 | |

### 4.2 变量声明

```iec
VAR                          (* 局部变量 *)
    x : INT := 0;
    name : STRING := 'Motor1';
END_VAR

VAR_INPUT                    (* 输入参数 *)
    setpoint : REAL;
END_VAR

VAR_OUTPUT                   (* 输出参数 *)
    result : BOOL;
END_VAR

VAR_IN_OUT                   (* 输入/输出参数 *)
    buffer : ARRAY[0..9] OF INT;
END_VAR

VAR CONSTANT                 (* 常量 *)
    PI : REAL := 3.14159;
END_VAR

VAR RETAIN                   (* 掉电保持变量 *)
    totalCount : DINT := 0;
END_VAR
```

### 4.3 控制结构

```iec
(* IF-ELSIF-ELSE *)
IF temperature > 80.0 THEN
    alarm := TRUE;
ELSIF temperature > 60.0 THEN
    warning := TRUE;
ELSE
    alarm := FALSE;
    warning := FALSE;
END_IF;

(* CASE *)
CASE state OF
    0: (* 空闲 *)
        motor := FALSE;
    1: (* 运行 *)
        motor := TRUE;
    2: (* 停止 *)
        motor := FALSE;
        state := 0;
END_CASE;

(* FOR 循环 *)
FOR i := 0 TO 9 DO
    data[i] := 0;
END_FOR;

(* WHILE 循环 *)
WHILE count < 100 DO
    count := count + 1;
END_WHILE;

(* REPEAT-UNTIL 循环 *)
REPEAT
    count := count + 1;
UNTIL count >= 100
END_REPEAT;
```

### 4.4 函数（FUNCTION）

函数是无状态的，每次调用都是独立的：

```iec
FUNCTION Scale : REAL
VAR_INPUT
    rawValue : INT;
    rawMin : INT;
    rawMax : INT;
    engMin : REAL;
    engMax : REAL;
END_VAR

Scale := engMin + (INT_TO_REAL(rawValue - rawMin) /
         INT_TO_REAL(rawMax - rawMin)) * (engMax - engMin);

END_FUNCTION
```

调用方式：

```iec
temperature := Scale(
    rawValue := sensorADC,
    rawMin := 0,
    rawMax := 4095,
    engMin := 0.0,
    engMax := 100.0
);
```

### 4.5 功能块（FUNCTION_BLOCK）

功能块是有状态的，实例化后在每个扫描周期中保持内部状态：

```iec
FUNCTION_BLOCK MotorController
VAR_INPUT
    start : BOOL;
    stop : BOOL;
    speed_sp : REAL;     (* 速度设定值 *)
END_VAR
VAR_OUTPUT
    running : BOOL;
    speed_pv : REAL;     (* 速度过程值 *)
    fault : BOOL;
END_VAR
VAR
    state : INT := 0;    (* 内部状态 *)
    timer : TON;         (* 标准库定时器 *)
END_VAR

CASE state OF
    0: (* 待机 *)
        running := FALSE;
        speed_pv := 0.0;
        IF start AND NOT fault THEN
            state := 1;
        END_IF;

    1: (* 加速 *)
        running := TRUE;
        speed_pv := speed_pv + 1.0;
        IF speed_pv >= speed_sp THEN
            speed_pv := speed_sp;
            state := 2;
        END_IF;

    2: (* 运行 *)
        IF stop THEN
            state := 3;
        END_IF;

    3: (* 减速 *)
        speed_pv := speed_pv - 2.0;
        IF speed_pv <= 0.0 THEN
            speed_pv := 0.0;
            running := FALSE;
            state := 0;
        END_IF;
END_CASE;

END_FUNCTION_BLOCK
```

使用功能块：

```iec
PROGRAM Main
VAR
    motor1 : MotorController;  (* 实例化功能块 *)
    btnStart : BOOL;
    btnStop : BOOL;
END_VAR

(* 调用功能块 *)
motor1(
    start := btnStart,
    stop := btnStop,
    speed_sp := 1500.0
);

(* 读取输出 *)
IF motor1.fault THEN
    (* 处理故障 *)
END_IF;

END_PROGRAM
```

### 4.6 用户自定义类型

```iec
(* 枚举 *)
TYPE MotorState : (
    IDLE,
    STARTING,
    RUNNING,
    STOPPING,
    FAULT
);
END_TYPE

(* 结构体 *)
TYPE MotorData :
STRUCT
    name : STRING[32];
    state : MotorState;
    speed : REAL;
    current : REAL;
    temperature : REAL;
    runHours : DINT;
END_STRUCT;
END_TYPE

(* 数组 *)
TYPE TenInts : ARRAY[0..9] OF INT;
END_TYPE
```

---

## 第五步：构建完整项目

一个典型的 PLC 项目包含多个文件。推荐的项目结构：

```
my-project/
├── DataTypes.st          (* 自定义类型定义 *)
├── GlobalVars.st         (* 全局变量声明 *)
├── Utilities.st          (* 辅助函数 *)
├── PID_Controller.st     (* PID 功能块 *)
├── MotorControl.st       (* 电机控制功能块 *)
├── AlarmHandler.st       (* 报警处理功能块 *)
├── MainProgram.st        (* 主程序 — 入口 *)
├── MotorLogic.fbd.json   (* FBD 图形化程序 *)
├── SafetyLogic.ld.json   (* LD 梯形图程序 *)
└── TrafficLight.sfc.json (* SFC 顺序控制程序 *)
```

### 全局变量示例（GlobalVars.st）

```iec
VAR_GLOBAL
    (* 传感器输入 *)
    temperature_raw : INT;
    pressure_raw : INT;
    level_raw : INT;

    (* 计算值 *)
    temperature : REAL;
    pressure : REAL;
    level : REAL;

    (* 设定值 *)
    temp_setpoint : REAL := 75.0;
    pressure_setpoint : REAL := 5.0;

    (* 控制输出 *)
    heater_output : REAL;
    valve_position : REAL;

    (* 状态标志 *)
    system_ready : BOOL;
    emergency_stop : BOOL;
    alarm_active : BOOL;
END_VAR
```

### 主程序示例（MainProgram.st）

```iec
PROGRAM MainProgram
VAR
    motor1 : MotorController;
    pid_temp : PID_Controller;
    alarms : AlarmHandler;
    cycle_count : DINT := 0;
END_VAR

(* 传感器缩放 *)
temperature := Scale(temperature_raw, 0, 4095, 0.0, 150.0);
pressure := Scale(pressure_raw, 0, 4095, 0.0, 10.0);

(* PID 温度控制 *)
pid_temp(
    setpoint := temp_setpoint,
    process_value := temperature,
    kp := 2.0,
    ki := 0.5,
    kd := 0.1
);
heater_output := pid_temp.output;

(* 电机控制 *)
motor1(
    start := system_ready AND NOT emergency_stop,
    stop := emergency_stop,
    speed_sp := 1500.0
);

(* 报警处理 *)
alarms(
    temp_high := temperature > 90.0,
    pressure_high := pressure > 8.0
);
alarm_active := alarms.any_active;

cycle_count := cycle_count + 1;

END_PROGRAM
```

### 多文件编译

IECC2 支持多文件项目编译与链接：

```bash
# IDE 中使用 Build All 命令
# 或命令行：
iecc -emit-c -link -main -o dist/linked.c *.st
```

编译器会自动处理文件间的依赖关系（全局变量引用、功能块实例化等）。

---

## 第六步：使用代码模板

IECC2 提供了丰富的代码片段（Snippets），帮助你快速创建常用的代码结构。

在 `.st` 文件中输入以下前缀并按 `Tab` 键：

| 前缀 | 生成内容 |
|------|----------|
| `iec-program` | 完整的 PROGRAM 框架 |
| `iec-fb` | 完整的 FUNCTION_BLOCK 框架 |
| `iec-function` | 完整的 FUNCTION 框架 |
| `iec-struct` | TYPE...STRUCT...END_TYPE |
| `iec-enum` | TYPE...枚举...END_TYPE |
| `iec-gvl` | VAR_GLOBAL...END_VAR |
| `iec-if` | IF-THEN-END_IF |
| `iec-case` | CASE-OF-END_CASE |
| `iec-for` | FOR-TO-DO-END_FOR |
| `iec-while` | WHILE-DO-END_WHILE |
| `iec-ton` | TON 定时器实例 + 调用 |
| `iec-pid` | PID 功能块调用 |
| `iec-interface` | INTERFACE 定义 |
| `iec-method` | METHOD 定义 |
| `iec-property` | PROPERTY 定义 |

例如，输入 `iec-fb` 并按 Tab：

```iec
FUNCTION_BLOCK MyFB
VAR_INPUT
    enable : BOOL;
END_VAR
VAR_OUTPUT
    done : BOOL;
END_VAR
VAR

END_VAR

(* Implementation *)

END_FUNCTION_BLOCK
```

光标会自动定位到 `MyFB` 处，你可以直接输入功能块名称，然后按 Tab 跳到下一个编辑点。

---

## 第七步：在 IDE 中新建项目元素

除了手动创建文件，你还可以通过 IDE 命令快速创建各种项目元素：

### 新建 POU（Program Organization Unit）

1. 按 `Ctrl+Shift+P` → 输入 **"IEC: New POU"**
2. 选择类型：Program / Function Block / Function
3. 输入名称
4. 自动创建对应的 `.st` 文件并打开

### 新建数据类型（DUT）

1. 按 `Ctrl+Shift+P` → 输入 **"IEC: New Data Type"**
2. 选择类型：Struct / Enum
3. 输入名称

### 新建全局变量列表（GVL）

1. 按 `Ctrl+Shift+P` → 输入 **"IEC: New Global Variable List"**
2. 输入名称

### 新建接口（Interface）

1. 按 `Ctrl+Shift+P` → 输入 **"IEC: New Interface"**
2. 输入名称

所有这些命令都会使用内置模板创建规范的 ST 文件，并自动在 IEC Project 树中显示。

---

## 理解 Demo 工程结构

如果你在 [开箱即用 — 安装与快速上手](开箱即用-—-安装与快速上手.md) 中创建了 Demo 工程，以下是各文件的详细说明：

| 文件 | POU 类型 | 说明 |
|------|----------|------|
| `MainProgram.st` | PROGRAM | 主入口程序，调度所有 FB，引用全局变量 |
| `PID_Controller.st` | FUNCTION_BLOCK | PID 控制器（P/I/D + 积分限幅 + 输出钳位） |
| `MotorControl.st` | FUNCTION_BLOCK | 电机控制状态机（IDLE→STARTING→RUNNING→STOPPING） |
| `AlarmHandler.st` | FUNCTION_BLOCK | 报警处理（TON 延时确认 + 优先级） |
| `GlobalVars.st` | VAR_GLOBAL | 传感器值、设定值、控制输出、状态标志 |
| `DataTypes.st` | TYPE | MotorState（ENUM）、MotorData（STRUCT）、AlarmEntry（STRUCT） |
| `Utilities.st` | FUNCTION | Scale / Clamp / DeadBand / BoolToInt 辅助函数 |

Demo 工程展示了一个典型的工业控制场景：**电机调速控制系统**，包含 PID 温度控制、电机状态机、报警管理，以及 FBD/LD/SFC 三种图形化编程示例。

---

## 常见问题

### Q: 编译提示 "undefined reference" 错误？

**A**: 确保所有被引用的功能块和函数在同一项目目录下，使用 `Build All` 命令编译整个项目而非单个文件。

### Q: 变量类型不匹配怎么办？

**A**: IEC 61131-3 是强类型语言，需要显式类型转换：

```iec
(* 错误 *)
myReal := myInt;

(* 正确 *)
myReal := INT_TO_REAL(myInt);
```

### Q: 如何在多个程序间共享变量？

**A**: 使用全局变量（VAR_GLOBAL）。创建一个 `GlobalVars.st` 文件：

```iec
VAR_GLOBAL
    shared_value : INT;
END_VAR
```

然后在任何程序或功能块中直接引用 `shared_value`。

### Q: 注释怎么写？

**A**: IEC 61131-3 使用 `(*` 和 `*)` 作为注释分隔符：

```iec
(* 这是单行注释 *)

(*
   这是
   多行注释
*)

// 单行注释（CODESYS 扩展语法，也支持）
```

---

**上一步**：[开箱即用 — 安装与快速上手](开箱即用-—-安装与快速上手.md)
**下一步**：[调试与仿真](调试与仿真.md)
