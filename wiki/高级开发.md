# 高级开发 — 图形化编程、库管理与 HMI

本教程介绍 IECC2 的高级开发能力：FBD/LD/SFC 图形化编程、标准库与库管理、HMI 设计器、多后端编译以及高级编译选项。

## 目录

- [前置要求](#前置要求)
- [图形化编程](#图形化编程)
- [标准库与库管理](#标准库与库管理)
- [HMI 设计器](#hmi-设计器)
- [多后端编译](#多后端编译)
- [高级编译选项](#高级编译选项)
- [OOP 面向对象编程](#oop-面向对象编程)
- [常见问题](#常见问题)

---

## 前置要求

- 已完成 [调试与仿真](调试与仿真.md)
- 熟悉 ST 语言基础

---

## 图形化编程

IECC2 支持 IEC 61131-3 标准定义的三种图形化编程语言，通过 VS Code 自定义编辑器实现。

### FBD — 功能块图（Function Block Diagram）

FBD 是一种基于数据流的图形化编程语言，通过连接功能块的输入/输出端口来描述逻辑。

#### 创建 FBD 程序

1. 在项目目录中新建文件，命名为 `MyLogic.fbd.json`
2. VS Code 自动以 FBD 图形编辑器打开
3. 也可以通过命令面板创建：`IEC: New POU` → 选择 FBD 类型

#### 编辑器操作

| 操作 | 方法 |
|------|------|
| 添加功能块 | 从右侧 **Components** 面板拖拽到画布 |
| 连线 | 从输出端口拖拽到输入端口 |
| 删除元素 | 选中后按 `Delete` |
| 移动元素 | 拖拽功能块到新位置 |
| 缩放 | 鼠标滚轮 |
| 平移 | 按住中键/空格键拖拽 |
| 撤销/重做 | `Ctrl+Z` / `Ctrl+Shift+Z` |

#### 组件浏览器

编辑 FBD/LD/SFC 时，右侧面板显示 **Component Browser**，按分类提供可用组件：

| 分类 | 组件 |
|------|------|
| **Logic** | AND, OR, NOT, XOR, RS, SR |
| **Arithmetic** | ADD, SUB, MUL, DIV, MOD |
| **Comparison** | EQ, NE, GT, GE, LT, LE |
| **Timer/Counter** | TON, TOF, TP, CTU, CTD, CTUD |
| **Math** | ABS, SQRT, SIN, COS, MIN, MAX, LIMIT |
| **Edge** | R_TRIG, F_TRIG |
| **Conversion** | INT_TO_REAL, REAL_TO_INT, BOOL_TO_INT |
| **User FBs** | 项目中定义的功能块 |

#### FBD 示例

Demo 工程中的 `MotorLogic.fbd.json` 展示了一个电机启停逻辑：

```
  ┌───────────┐
  │ Start_Btn │──┐
  └───────────┘  │   ┌─────┐        ┌──────┐
                 ├──▶│ AND │──────▶│  SR  │──▶ Motor_Run
  ┌───────────┐  │   │     │        │      │
  │ NOT       │──┘   └─────┘   ┌──▶│  R   │
  │  E_Stop   │               │   └──────┘
  └───────────┘    ┌──────────┐│
                   │ Stop_Btn │┘
                   └──────────┘
```

### LD — 梯形图（Ladder Diagram）

LD 是 PLC 最经典的编程语言，使用继电器逻辑符号表示。

#### 创建 LD 程序

新建文件命名为 `MyLadder.ld.json`，VS Code 自动以 LD 编辑器打开。

#### LD 元素

| 元素 | 符号 | 说明 |
|------|------|------|
| 常开触点 | `─┤ ├─` | 变量为 TRUE 时导通 |
| 常闭触点 | `─┤/├─` | 变量为 FALSE 时导通 |
| 线圈 | `─( )─` | 将结果写入输出变量 |
| 取反线圈 | `─(/)─` | 将取反结果写入输出 |
| 置位线圈 | `─(S)─` | 置位（锁存 TRUE） |
| 复位线圈 | `─(R)─` | 复位（锁存 FALSE） |

#### LD 示例

Demo 工程中的 `SafetyLogic.ld.json` 展示了急停安全回路：

```
                  E_Stop_1    E_Stop_2    Guard_Door
  ├───────────┤ ├───────┤ ├───────┤ ├──────────( )─ Safety_OK
  │
  │ Safety_OK   Run_Cmd
  ├─────┤ ├───────┤ ├───────────────────────────(S)─ Motor_Enable
  │
  │           Stop_Cmd
  ├─────────────┤ ├─────────────────────────────(R)─ Motor_Enable
```

### SFC — 顺序功能图（Sequential Function Chart）

SFC 用于描述顺序控制流程，由步（Step）、转换（Transition）和动作（Action）组成。

#### 创建 SFC 程序

新建文件命名为 `MySequence.sfc.json`，VS Code 自动以 SFC 编辑器打开。

#### SFC 元素

| 元素 | 说明 |
|------|------|
| **初始步（Initial Step）** | 程序启动时的默认活动步 |
| **步（Step）** | 表示一个状态，可关联多个动作 |
| **转换（Transition）** | 步之间的条件，条件为 TRUE 时触发状态转移 |
| **动作（Action）** | 在步激活期间执行的代码 |
| **分支（Branch）** | 并行分支（同时激活多步）或选择分支（条件选择） |

#### 动作限定符

| 限定符 | 说明 |
|--------|------|
| `N` | 非存储（步激活期间持续执行） |
| `S` | 置位（步激活时置位，直到被 R 复位） |
| `R` | 复位（复位由 S 置位的动作） |
| `P` | 脉冲（步激活的第一个周期执行一次） |
| `L` | 时间限制（执行指定时间后自动停止） |
| `D` | 延时（步激活后延时一段时间再执行） |

#### SFC 示例

Demo 工程中的 `TrafficLight.sfc.json` 展示了交通灯控制：

```
  ┌──────────┐
  │  Init    │ (初始步)
  └────┬─────┘
       │ TRUE
  ┌────▼─────┐
  │  Green   │ ──── GreenLight := TRUE
  └────┬─────┘
       │ greenTimer.Q
  ┌────▼─────┐
  │  Yellow  │ ──── YellowLight := TRUE
  └────┬─────┘
       │ yellowTimer.Q
  ┌────▼─────┐
  │   Red    │ ──── RedLight := TRUE
  └────┬─────┘
       │ redTimer.Q
       └──────────▶ (回到 Green)
```

---

## 标准库与库管理

IECC2 提供了分层的标准库体系，覆盖从基础功能到工业协议的完整功能集。

### 库的分层结构

```
┌──────────────────────────────────────────────────┐
│  L3: Protocol Libraries (按需引用)                │
│  Modbus, MQTT, OPC UA, S7, CANopen, BACnet,      │
│  IEC 104, EtherCAT, PROFINET, EtherNet/IP        │
├──────────────────────────────────────────────────┤
│  L3: Control Libraries (按需引用)                 │
│  PID, Motion, Safety, Math Ext, String, DataLog  │
├──────────────────────────────────────────────────┤
│  L2: Standard Library (自动包含)                  │
│  Timer, Counter, Edge, Math, Type Conversion     │
└──────────────────────────────────────────────────┘
```

- **L2 标准库**：自动包含在每个项目中，无需手动引用
- **L3 控制库 / 协议库**：按需在库管理器中引用

### 打开库管理器

命令面板 → `IEC: Open Library Manager`

库管理器面板展示：

| 区域 | 说明 |
|------|------|
| **已安装库** | 当前项目引用的库列表 |
| **可用库** | 按分类浏览所有可用库 |
| **库详情** | 选中库后显示包含的函数/功能块列表 |

### 标准库内容一览

#### 定时器与计数器

| 名称 | 类型 | 说明 |
|------|------|------|
| `TON` | FB | 接通延时定时器 |
| `TOF` | FB | 断开延时定时器 |
| `TP` | FB | 脉冲定时器 |
| `CTU` | FB | 递增计数器 |
| `CTD` | FB | 递减计数器 |
| `CTUD` | FB | 双向计数器 |

使用示例：

```iec
VAR
    startDelay : TON;
    isReady : BOOL;
END_VAR

startDelay(IN := startButton, PT := T#3s);
isReady := startDelay.Q;  (* 按钮按下 3 秒后 isReady 变为 TRUE *)
```

#### 边沿检测

| 名称 | 类型 | 说明 |
|------|------|------|
| `R_TRIG` | FB | 上升沿检测 |
| `F_TRIG` | FB | 下降沿检测 |

#### 数学函数

| 名称 | 说明 |
|------|------|
| `ABS`, `SQRT`, `SIN`, `COS`, `TAN` | 基础数学 |
| `LN`, `LOG`, `EXP`, `EXPT` | 对数/指数 |
| `MIN`, `MAX`, `LIMIT`, `SEL`, `MUX` | 选择/限幅 |
| `MOD` | 取模 |

#### 扩展数学库（L3, 需手动引用）

| 名称 | 类型 | 说明 |
|------|------|------|
| `MOVING_AVG` | FB | 滑动平均 |
| `LOW_PASS_FILTER` | FB | 低通滤波 |
| `LINEAR_INTERP` | FC | 线性插值 |
| `CRC16` / `CRC32` | FC | 校验计算 |

#### PID 控制库（L3）

| 名称 | 类型 | 说明 |
|------|------|------|
| `PID` | FB | 标准 PID 控制器 |
| `PID_COMPACT` | FB | 紧凑型 PID |
| `PID_AUTOTUNE` | FB | PID 自整定 |
| `RAMP` | FB | 斜坡发生器 |
| `HYSTERESIS` | FB | 滞环控制 |

#### 运动控制库（L3）

| 名称 | 类型 | 说明 |
|------|------|------|
| `AXIS_REF` | FB | 轴引用 |
| `MC_POWER` | FB | 轴使能 |
| `MC_MOVE_ABSOLUTE` | FB | 绝对运动 |
| `MC_HOME` | FB | 回零 |

#### 安全库（L3）

| 名称 | 类型 | 说明 |
|------|------|------|
| `ESTOP_MONITOR` | FB | 急停监控 |
| `SAFETY_DOOR` | FB | 安全门监控 |
| `TWO_HAND` | FB | 双手操作 |
| `MUTING` | FB | 屏蔽控制 |

#### 通信协议库（L3）

| 协议 | 功能块 |
|------|--------|
| **Modbus** | `MODBUS_TCP_CLIENT`, `MODBUS_READ_REGISTERS`, `MODBUS_WRITE_REGISTER` |
| **MQTT** | `MQTT_CLIENT`, `MQTT_PUBLISH`, `MQTT_SUBSCRIBE` |
| **OPC UA** | `OPCUA_CLIENT`, `OPCUA_READ`, `OPCUA_WRITE` |
| **S7** | `S7_CLIENT`, `S7_READ_DB`, `S7_WRITE_DB` |
| **CANopen** | `CANOPEN_MASTER`, `CANOPEN_SDO_READ`, `CANOPEN_PDO_MAP` |
| **BACnet** | `BACNET_CLIENT`, `BACNET_READ_PROPERTY` |
| **IEC 104** | `IEC104_CLIENT`, `IEC104_SERVER` |
| **EtherCAT** | `EC_MASTER`, `EC_SLAVE_READ` |
| **PROFINET** | `PN_CONTROLLER`, `PN_DEVICE_IO` |
| **EtherNet/IP** | `EIP_SCANNER`, `EIP_ADAPTER` |

### 使用库中的功能块

以 PID 控制器为例：

1. 打开库管理器 → 找到 "PID Control" 库 → 点击添加
2. 在 ST 代码中直接使用：

```iec
PROGRAM TempControl
VAR
    pid : PID;
    tempSensor : REAL;
    heaterOutput : REAL;
END_VAR

pid(
    setpoint := 75.0,
    process_value := tempSensor,
    kp := 2.0,
    ki := 0.5,
    kd := 0.1
);
heaterOutput := pid.output;

END_PROGRAM
```

---

## HMI 设计器

IECC2 内置 HMI（人机界面）设计器，可以创建简单的操作面板用于监控和控制。

### 打开 HMI 设计器

- 方式 A：双击项目中的 `.hmi.json` 文件
- 方式 B：命令面板 → `IEC: Open HMI Designer`

### 可用控件

| 控件 | 说明 | 用途 |
|------|------|------|
| **Gauge** | 仪表盘 | 显示模拟量值（温度、压力等） |
| **Lamp** | 指示灯 | 显示布尔状态（运行/停止/故障） |
| **Button** | 按钮 | 触发操作（启动/停止） |
| **Switch** | 开关 | 切换布尔变量 |
| **TrendChart** | 趋势图 | 显示变量随时间的变化曲线 |
| **NumericDisplay** | 数值显示 | 显示数值变量 |
| **TextDisplay** | 文本显示 | 显示字符串变量 |

### 变量绑定

每个控件都可以绑定到 PLC 变量：

1. 选中控件
2. 在属性面板中找到 **Variable** 属性
3. 输入变量路径，例如 `MainProgram.motor1.speed_pv`

### HMI 示例

Demo 工程中的 `Dashboard.hmi.json` 包含一个电机控制面板：

- **仪表盘**：显示电机速度（绑定 `motor1.speed_pv`）
- **指示灯**：显示运行状态（绑定 `motor1.running`）
- **按钮**：启动/停止控制（绑定 `btnStart` / `btnStop`）
- **开关**：自动/手动模式切换
- **趋势图**：温度和压力的实时曲线

---

## 多后端编译

IECC2 支持将 IEC 61131-3 程序编译为多种目标格式。

### ANSI C（默认后端）

```bash
iecc -emit-c -o output.c program.st
```

生成标准 ANSI C 代码，可用 GCC/Clang 编译为任意目标平台的可执行文件。这是工业部署的主要后端。

### LLVM IR

```bash
iecc -emit-llvm -g -o output.ll program.st
```

生成 LLVM IR 文本格式：
- `-g` 选项生成 DWARF 调试信息
- 可使用 LLVM 工具链（`llc`、`opt`）做进一步优化
- 支持所有 LLVM 目标平台

### WebAssembly

```bash
iecc -emit-wasm -o output.wat program.st
```

生成 WebAssembly 文本格式（WAT）：
- 可用 `wat2wasm` 转换为二进制 `.wasm`
- 适合浏览器内仿真和在线演示
- 适合边缘计算场景

### OPC UA NodeSet XML

```bash
iecc -emit-nodeset program.st
```

从 PLC 程序中提取变量信息，生成 OPC UA NodeSet2 XML 文件，用于工业互联互通。

### 在 IDE 中切换后端

打开 VS Code 设置，修改 `iec-st.buildBackend`：

| 值 | 后端 |
|----|------|
| `c` | ANSI C（默认） |
| `llvm` | LLVM IR |
| `wasm` | WebAssembly |

---

## 高级编译选项

### 增量编译

```bash
iecc -incremental -cache-dir .build program.st
```

增量编译会缓存未修改文件的编译结果，大幅加速重编译：

- 编译缓存存储在 `-cache-dir` 指定的目录
- 仅重编译修改过的文件
- 使用 `-clean` 清除缓存

### 并行编译

```bash
iecc -j 8 -link -o output.c *.st
```

多文件项目支持并行编译：

- `-j 0`：自动检测 CPU 核心数
- `-j N`：指定 N 个并行工作进程
- 在 IDE 中通过 `iec-st.buildParallel` 设置

### IR 优化

默认启用优化（`-O`），包括以下优化遍：

| 优化 | 说明 |
|------|------|
| 常量折叠 | 编译期计算常量表达式 |
| 死代码消除 | 移除不可达代码 |
| 拷贝传播 | 消除冗余赋值 |
| SSA | 静态单赋值变换 |
| 强度削减 | 用低代价操作替换高代价操作 |
| 公共子表达式消除 | 避免重复计算 |
| 循环优化 | 循环不变量外提、循环展开 |

### PGO — 基于配置文件的优化

```bash
# 1. 先进行性能分析运行，生成 profile
iec-sim -profile output.iecprof program.st

# 2. 使用 profile 数据重新编译
iecc -pgo output.iecprof -o optimized.c program.st
```

PGO 根据实际运行热点数据进行针对性优化。

### LLVM 优化集成

```bash
iecc -emit-llvm -llvm-opt -o optimized.ll program.st
```

在生成的 LLVM IR 上运行 LLVM 优化流水线，获得更高性能的代码。

---

## OOP 面向对象编程

IECC2 支持 IEC 61131-3 第三版的 OOP 扩展：

### 接口（Interface）

```iec
INTERFACE IMotor
    METHOD Start
    END_METHOD

    METHOD Stop
    END_METHOD

    PROPERTY Speed : REAL
    END_PROPERTY
END_INTERFACE
```

### 类（Class）— 通过功能块实现

```iec
FUNCTION_BLOCK ServoMotor IMPLEMENTS IMotor
VAR
    _speed : REAL;
    _running : BOOL;
END_VAR

METHOD Start
    _running := TRUE;
END_METHOD

METHOD Stop
    _running := FALSE;
    _speed := 0.0;
END_METHOD

PROPERTY Speed : REAL
    GET
        Speed := _speed;
    END_GET
    SET
        IF _running THEN
            _speed := Speed;
        END_IF;
    END_SET
END_PROPERTY

END_FUNCTION_BLOCK
```

### 继承（Extends）

```iec
FUNCTION_BLOCK AdvancedMotor EXTENDS ServoMotor
VAR
    _acceleration : REAL := 10.0;
END_VAR

METHOD SetAcceleration
VAR_INPUT
    acc : REAL;
END_VAR
    _acceleration := acc;
END_METHOD

END_FUNCTION_BLOCK
```

### 访问修饰符

| 修饰符 | 说明 |
|--------|------|
| `PUBLIC` | 公开访问（默认） |
| `PRIVATE` | 仅本类访问 |
| `PROTECTED` | 本类及子类访问 |
| `INTERNAL` | 同一项目内访问 |

---

## 常见问题

### Q: FBD 编辑器打不开？

**A**: 确认文件扩展名为 `.fbd.json`。如果文件以普通文本编辑器打开，右键文件标签 → "Reopen Editor With..." → 选择 "FBD Editor"。

### Q: 如何将 FBD/LD/SFC 图形化程序与 ST 程序混合使用？

**A**: 图形化程序会被编译为等效的 ST 代码，然后参与统一编译。你可以在 MainProgram.st 中通过功能块实例的方式调用图形化程序生成的功能块。

### Q: 库管理器中的库存放在哪里？

**A**: 标准库源码位于项目的 `stdlib/` 目录下，以 ST 源文件和对应的 C 实现提供。库的元数据定义在 `stdlib/catalog.json` 中。

### Q: WebAssembly 后端有什么限制？

**A**: 当前 WASM 后端生成 WAT（文本格式），需要 `wat2wasm` 工具转换为二进制。部分高级特性（指针操作、动态内存）在 WASM 中有限制。

---

**上一步**：[调试与仿真](调试与仿真.md)
**下一步**：[工业化部署架构方案](工业化部署架构方案.md)
